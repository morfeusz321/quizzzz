package server.game.questions;

import org.apache.commons.lang3.tuple.Pair;
import org.springframework.stereotype.Component;

import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import java.util.Random;

@Component
public class QuestionGeneratorUtils {

    /**
     * Empty constructor, creates an instance of the QuestionGeneratorUtils
     */
    public QuestionGeneratorUtils(){}

    /**
     * Generates a (random) upper/lower bound for a given consumption, which is used to generate the new activities
     * with a close consumption to this one. The bound is dependent on the "scale" of the given consumption. The input
     * should be non-negative.
     * @param consumption the consumption from which to generate a range
     * @return an array with two longs, the lower bound (idx 0) and the upper bound (idx 1)
     */
    public long[] getLowerUpperBoundSmall(long consumption){
        // This is a method that creates a "small" range, that is closer to the initial value.
        // The range does not have to be generated randomly, as the activity itself is chosen randomly
        // within that range.
        if(consumption <= 500){
            return new long[]{0, 500};
        } else if(consumption <= 1000){
            return new long[]{500, 1000};
        } else if(consumption <= 10000){
            return new long[]{1000,10000};
        } else if(consumption <= 100000){
            return new long[]{10000,10000000L};
        } else if(consumption <= 10000000L){
            return new long[]{100000,1000000000L};
        } else if(consumption <= 1000000000L){
            return new long[]{10000000L,100000000000L};
        } else if(consumption <= 100000000000L){
            return new long[]{1000000000L,100000000000L};
        } else {
            return new long[]{100000000000L,Long.MAX_VALUE};
        }
    }

    /**
     * Creates a string from a given consumption in Wh that is rounded to 2 decimals and uses SI prefixes such
     * as k (kilo, i.e. 1 000) and M (Mega, i.e. 1 000 000) to make it easier to read
     * @param consumption the consumption in Wh
     * @return a string of the consumption using SI prefixes and rounded to 2 decimals
     */
    public String createConsumptionString(long consumption) {

        return createConsumptionString(consumption, 2);

    }

    /**
     * Gives the max. percentage value for the range in which to generate answer options for the general question
     * type, i.e. the answer options are then generated by random((lower percentage), this percentage) * consumption.
     * @param consumption The consumption of the activity for which to generate the percentage.
     * @return The max. percentage value for the range in which to generate answer options for the general question.
     */
    public double getMaxPercentageGeneral(long consumption) {

        // This formula generates a bigger range, i.e. a maximum of 5, and a minimum of 0.4.
        // The exact percentage value depends on the consumption of the activity. This means that, if the
        // consumption is smaller, the range percentage will be higher (so that a sufficiently big/small
        // range is generated).

        // f(x) = 5*e^(-9.77074*10^(-17)*x)
        return 5 * Math.pow(2.71828, -9.77074 * Math.pow(10, -17) * consumption);

    }

    /**
     * Creates a string from a given consumption in Wh that is rounded to the provided amount of decimals
     * and uses SI prefixes such as k (kilo, i.e. 1 000) and M (Mega, i.e. 1 000 000) to make it easier to read
     * @param consumption the consumption in Wh
     * @return a string of the consumption using SI prefixes and rounded to the provided amount of decimals, or an
     * IllegalArgumentException if the amount of decimals or the consumption is negative
     */
    public String createConsumptionString(long consumption, int amountOfDecimals) throws IllegalArgumentException {

        if(amountOfDecimals < 0) throw new IllegalArgumentException("Amount of decimals cannot be negative!");
        if(consumption < 0) throw new IllegalArgumentException("Consumption cannot be negative!");

        if(consumption < 1000) return consumption + " Wh";

        StringBuilder stringBuilder = new StringBuilder();

        double doubleConsumption = (double) consumption;
        int steps = 0;
        while(doubleConsumption >= 1000.0 && steps < 4) {
            doubleConsumption /= 1000.0;
            steps++;
        }

        double roundingFactor = Math.pow(10, amountOfDecimals);
        double rounded = ((double) Math.round(doubleConsumption * roundingFactor)) / roundingFactor;

        String formatString = "%." + amountOfDecimals + "f";
        stringBuilder.append(String.format(Locale.ENGLISH, formatString, rounded)).append(" ").append(getSIPrefix(steps)).append("Wh");
        return stringBuilder.toString();

    }

    /**
     * Gets the SI prefix for a provided division step by 1 000, for example, one division by 1 000 gives the
     * prefix "k" for kilo (1 000), or two division steps give the prefix "M" for Mega (1 000 000)
     * @param step the amount of division steps by 1 000, (at most 4)
     * @return the appropriate prefix for the amount of division steps by 1 000, or an IllegalArgumentException
     * in case the amount of steps is greater than 4
     */
    public String getSIPrefix(int step) throws IllegalArgumentException {

        if(step <= 0) {
            return "";
        } else if(step == 1) {
            return "k";
        } else if(step == 2) {
            return "M";
        } else if(step == 3) {
            return "G";
        } else if(step == 4) {
            return "T";
        } else {
            throw new IllegalArgumentException("The amount of division steps cannot be greater than 4!");
        }

    }

    /**
     * Generates random number from given range excluding those given as the parameter
     * @param rnd Instant of the Random class
     * @param start the start of the range in which the number will be generated
     * @param end the end of the range in which the number will be generated
     * @param exclude numbers that will be excluded from the given range
     * @return random number in given range (number is rounded to first decimal place)
     */
    public double getRandomWithExclusion(Random rnd, double start, double end, int... exclude) {
        double random = start + (end - start) * rnd.nextDouble();
        random = (double) Math.round(random * 10) / 10;
        for (int ex : exclude) {
            if (random == (double) ex) {
                return getRandomWithExclusion(rnd, start, end, exclude);
            }
        }
        return random;
    }

    /**
     * Returns whether it is feasible to generate a random number in a given range, provided with exclusion ranges
     * in this range
     * @param excluded The points around which certain percentages should be excluded
     * @param percentExcl The percentage that should be excluded around each exclusion point in +/- direction (PER direction, not total)
     * @param lower The lower bound of the range that numbers are to be generated in
     * @param upper The upper bound of the range that numbers are to be generated in
     * @return Whether the probability of generating a random value in the range on the first try is at least 50% (true/false)
     */
    public boolean checkIfGeneratable(List<Long> excluded, double percentExcl, long lower, long upper) {

        if(lower == 0 && upper == 0) {
            // Something went wrong, this can/should not be generated
            return false;
        }

        if(lower == upper) {
            // Special case where the upper bound equals the lower bound
            return !excluded.contains(upper);
        }

        // Special case where there are no exclusions; this range is always generatable
        if(excluded.size() == 0) return true;

        // Crop all ranges with their exclusion percentages to fit withing the bounds provided
        // Converts the single exclusion point into a pair of min, max = bounds of the exclusion range
        List<Pair<Long, Long>> excludedCropped = new ArrayList<>();
        excluded.forEach(l -> {
            long min = Math.round(l - l * percentExcl);
            long max = Math.round(l + l * percentExcl);
            if(min < lower) min = lower;
            if(max > upper) max = upper;
            excludedCropped.add(Pair.of(min, max));
        });

        // Converts the exclusion ranges into independent ranges that are non-overlapping
        List<Pair<Long, Long>> excludedCroppedNonOverlapping = new ArrayList<>();
        excludedCroppedNonOverlapping.add(excludedCropped.get(0));
        excludedCropped.forEach(range -> {
            long min = range.getLeft();
            long max = range.getRight();
            boolean overlapDetected = false;
            for(int i = 0; i < excludedCroppedNonOverlapping.size(); i++) {
                Pair<Long, Long> finalRange = excludedCroppedNonOverlapping.get(i);
                long fMin = finalRange.getLeft();
                long fMax = finalRange.getRight();
                if(!(min > fMax || max < fMin)) {
                    overlapDetected = true;
                } else continue;
                excludedCroppedNonOverlapping.set(i, Pair.of(Math.min(min, fMin), Math.max(max, fMax)));
            }
            if(!overlapDetected) excludedCroppedNonOverlapping.add(range);
        });

        // Calculate the total size of all the non-overlapping exclusion zones combined
        long totalExclusionRangeSize = 0;
        for(Pair<Long, Long> range : excludedCroppedNonOverlapping) {
            totalExclusionRangeSize += range.getRight() - range.getLeft();
        }

        // Calculate the total size of the range
        long totalRangeSize = upper - lower;

        return ((double) totalExclusionRangeSize) / totalRangeSize <= 0.5;

    }

    /**
     * Returns a random long in a given range, with both the lower and upper bound inclusive.
     * If the bounds are equal, this method simply returns the lower bound. Some numbers can be excluded.
     * @param lower The lower bound (inclusive)
     * @param upper The upper bound (inclusive)
     * @param r A random number generator
     * @param excludeSIString SI Strings that should be excluded
     * @param excludedNumbers Values that values should be excluded around (in a certain percentage range)
     * @param percentExcl The percentage range in which values should be excluded
     * @return A random long in the given range (both bounds inclusive) which is not equal to the excluded values.
     */
    public long randomLongInRangeExcl(
            long lower,
            long upper,
            Random r,
            List<String> excludeSIString,
            List<Long> excludedNumbers,
            double percentExcl
    ){

        // The lower bound may never be strictly greater than the upper bound
        if(lower > upper) {
            throw new IllegalArgumentException();
        }

        // Special cases where the upper bound equals the lower bound
        if(lower == upper) {
            // If the bound is excluded, no number can be generated at all
            // Theoretically it would aldo be necessary to check all excluded bounds, however checkIfGeneratable
            // should make sure that this is only called when it really is generatable
            // So we can assume that this should in fact never even be the case
            if(excludedNumbers.contains(lower) || excludeSIString.contains(createConsumptionString(lower))) {
                throw new IllegalArgumentException();
            }
            // Otherwise, we can simply return one of the bounds - this is valid, because both bounds are inclusive
            return lower;
        }

        // We use the lower bound as an offset for this range to give us the desired range.
        // Random.nextDouble() has to be used as there is no method for longs that 1. can have a limit and 2. returns
        // all possible long values.
        long random = (long) (r.nextDouble() * (upper - lower) + lower);

        // Check excluded SI Strings
        for (String ex : excludeSIString) {
            if (createConsumptionString(random).equals(ex)) {
                return randomLongInRangeExcl(lower, upper, r, excludeSIString, excludedNumbers, percentExcl);
            }
        }

        // Check excluded values in ranges
        for (Long ex : excludedNumbers) {
            if (random <= (ex + ex * percentExcl) && random >= (ex - ex * percentExcl)) {
                return randomLongInRangeExcl(lower, upper, r, excludeSIString, excludedNumbers, percentExcl);
            }
        }

        return random;

    }

    /**
     * Returns the bounds in which to generate the consumption values (answer options) for the general question.
     * @param consumption The consumption which is the answer to the question.
     * @return the bounds in which to generate the consumption values (answer options) for the general question.
     */
    public long[] getBoundsGeneralQuestion(long consumption) {
        // Get the maximal percentage while using the formula in getMaxPercentageGeneral, for the given consumption
        double maxPercentage = getMaxPercentageGeneral(consumption);
        // Generate the bounds, left bound should be 1/2 the percentage shifted and right too.
        long[] bounds = new long[]{
                (long) (consumption * (1 - maxPercentage / 2)),
                (long) (consumption * (1 + maxPercentage / 2))
        };
        // Perform safety check (checks negative bounds, shift/cut-off if necessary)
        safeBoundCheckGeneralQuestion(bounds, consumption);
        return bounds;
    }

    /**
     * Performs a "safety check" for the bounds, i.e. checks for negative bounds, and shifts/cuts it off if necessary.
     * This method is used for the general question generation.
     * @param bounds The bounds to check (two boundaries)
     * @param consumption The consumption of the original activity
     */
    public void safeBoundCheckGeneralQuestion(long[] bounds, long consumption){
        // Cut-off to not create too large bounds
        if (bounds[0] < 0) {
            if(bounds[1] <= 20){
                // If it is very small, shift instead of cut-off
                bounds[1] = bounds[1] - bounds[0];
            } else if(Math.abs(bounds[0]) < Math.abs(bounds[1]) && (bounds[1] + bounds[0]) > consumption){
                // First check if the absolute lower bound is not bigger or equal to the absolute upper bound
                // AND that the result would be bigger than the actual consumption (as it otherwise would only generate
                // values below the consumption)
                bounds[1] = bounds[1] + bounds[0];
                // Cut off so that it is not more likely to have a larger number
                // Note that this is + and not - on purpose for the above reason
            }
            bounds[0] = 0;
        }
    }

    /**
     * Generates random number from given range excluding those given as the parameter
     * @param rnd Instant of the Random class
     * @param start the start of the range in which the number will be generated
     * @param end the end of the range in which the number will be generated
     * @return random number in given range (number is not rounded)
     */
    public double getRandomDoubleInRange(Random rnd, double start, double end) {
        return start + (end - start) * rnd.nextDouble();
    }

    /**
     * Generates bounds for the input range for the estimation question.
     * @param consumption The consumption of the activity for which to generate the range.
     * @return The bounds for the estimation question input.
     */
    public int[] getBoundsEstimationQuestion(Random rnd, int consumption) {
        // Find the maximum percentage of the consumption which defines the maximum length of the range.
        // This uses a function which was fitted to certain values, which logically and game-wise make sense,
        // so that there are not only certain threshold values, but a continuous distribution.
        // It is a logarithmic function, so that, as the consumption grows, the actual range does not grow
        // as large.
        double maxPercentage = 11.4 - 0.8 * Math.log(consumption);
        double minPercentage = maxPercentage * 0.8;
        // Generate a random percentage in the range
        double percentage = getRandomDoubleInRange(rnd, minPercentage, maxPercentage);
        // The range is set to a value, however, the start- and end-values will be generated from this range.
        // We can cast to int as range/consumption are expected to not be longs.
        int range = (int) (percentage * consumption);
        // Minimum and maximum range conditions
        if(range < 200){
            range = 200;
        } else if(range > 500000){
            range = 500000;
        }

        // Generate the shift percentage values
        double shiftMinPercentage = rnd.nextDouble() + 0.2;
        if(shiftMinPercentage > 1){
            shiftMinPercentage = 1;
        }
        double shiftMaxPercentage = 1 - shiftMinPercentage;

        // Create min/max bounds
        int min = (int) (consumption - shiftMinPercentage * range);
        int max = (int) (consumption + shiftMaxPercentage * range);

        // First check lower bound as that should not be negative
        if(min < 0) {
            max = max - min;
            min = 0;
        }

        // Round the ranges to 10Wh
        min = (int) (Math.round(min/10.0) * 10);
        max = (int) (Math.round(max/10.0) * 10);

        // Now check upper bound
        if(max > 999999 && (min - max) > 0) {
            min = min - max;
            max = 999999;
        }

        return new int[]{min, max};
    }

}
